---
title: "数据库事务隔离级别"
date: 2019-05-22T21:48:03+08:00
draft: false
categories: ["数据库", "学习笔记"]
tags: ["数据库","MySQL"]
keyword: ["数据库","事务","隔离级别"]
slug: Database Transaction Isolation
---

## 定义

* 脏读（ Dirty Read ）：当事务 A 对数据进行修改后，事务 B 读取了被改动后的数据，此时事务 A 进行了异常回滚，事务B读取到的是未经提交的数据，称之为脏读。
* 不可重复读（ NonRepeatable Read ）：事务 A 中读取了数据后，事务 B 对数据进行了修改并提交，事务 A 再次对数据进行读取发现前后不一致，称之为不可重复读。
* 幻读（ Phantom Read ）：事务 A 在读取某个范围内的记录时，事务 B 在该范围内插入了新的记录，事务 A 再次进行数据统计后得到不同的结果，称之为幻读。

PS：不可重复读和幻读从结果上看十分相似，都是数据在两次读取间隔间进行修改导致两次读取的结果不一致，他们的区别在于：

1. 不可重复读指的是一个事务内对同一数据的多次读取的情况。
2. 幻读指的是事务的读取范围被其他事务改变的情况。

## 隔离级别

在 SQL 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见或不可见的。较低级的隔离级别一般系统的开销也更低，可以支撑更高的并发，但是对上层应用的数据读取可能会造成影响。

### READ UNCOMMITTED 未提交读

在 READ UNCOMMITTED 隔离级别下，事务可以对其他事务中尚未提交的数据修改进行读取。这个级别会导致很多问题，比如脏读，在实际应用中一般很少使用。

### READ COMMITTED 提交读

在 READ COMMITTED 隔离级别下，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。该隔离级别避免了脏读的发生，但是一个事务内的查询，依然有可能获得不同的结果（数据被其他事务修改），导致产生不可重复读。

### REPEATABLE READ 可重复读

REPEATABLE READ 解决了脏读&不可重复读的问题，该隔离级别保证了在同一个事务中多次读取同样的记录结果是一致的。但是该隔离级别依然会导致幻读的问题。

PS：在 SQL 标准中，REPEATABLE READ 无法解决幻读的问题，但是 MySQL 中 InnoDB 和 XtraDB 存储引擎通过[多版本并发控制（ MVCC，MultiVersion Concurrency Control ）](../mysql-multiversion-concurrency-control/)解决了幻读的问题。

### SERIALIZABLE 可串行化

SERIALIZABLE 是最高的隔离级别，通过强制事务串行执行，避免了数据的读取问题。该隔离级别对读取的每一行数据都进行加锁，可能会因为大量的超时和锁调度的问题导致性能下降。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| :--------------- | :--: | :--------: | :--: | :----: |
| READ UNCOMMITTED |  √   |     √      |  √   |   X    |
| READ COMMITTED   |  X   |     √      |  √   |   X    |
| REPEATABLE READ  |  X   |     X      |  √   |   X    |
| SERIALIZABLE     |  X   |     X      |  X   |   √    |


## 总结

- READ UNCOMMITTED：从性能上来讲，未提交读不会比其他隔离级别好太多，但是带来的问题和风险远远高于其他隔离级别。除非真的有足够必要的使用理由，否则远离他。

- READ COMMITTED：大多数数据库的默认隔离级别都是提交读，如 SQL Server，Oracle。解决了脏读的问题，但是无法避免数据被其他事务修改过程前后读取不一致的情况。
- REPEATABLE READ：在 MySQL 中，可重复读是默认的事务隔离级别，保障了一个事务在多次读取数据过程中，其他数据无法操作该数据。但是依然避免不了新数据的插入，产生幻读。
- SERIALIZABLE：完全串行化地执行事务，每次读都需要获得表级共享锁，最安全，也是性能最差的隔离级别。只有在非常x3需要确保数据一致性而且可以接受无法并发的情况，才能考虑使用。