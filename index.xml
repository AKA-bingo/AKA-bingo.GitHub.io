<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BinGo&#39;s Blog on BinGo&#39;s Blog</title>
    <link>https://aka-bingo.github.io/</link>
    <description>Recent content in BinGo&#39;s Blog on BinGo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Sep 2019 20:49:19 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang Channel 学习笔记</title>
      <link>https://aka-bingo.github.io/2019/09/golang-channel-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 03 Sep 2019 20:49:19 +0800</pubDate>
      
      <guid>https://aka-bingo.github.io/2019/09/golang-channel-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Channel 是 Go 语言中并发模型的重要组成部分，可以在不同的 goroutine 之间进行数据的传输。&lt;/p&gt;

&lt;p&gt;在日常使用中，channel 可以分为两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无缓冲 channel：在无缓冲 channel 中，数据的发送和读取操作需要同时进行，当只有一个 goroutine A 进行数据的读取（写入）时，需要等待另一个 goroutine B 通过这个 channel 进行数据写入（读取）。在此之前 goroutine A 会一直阻塞，直到 goroutine B来拯救它。&lt;/li&gt;
&lt;li&gt;有缓冲 channel：在有缓冲 channel 中，会自带一个缓冲循环队列。当 goroutine 进行数据读取时，如果缓冲队列中有数据便直接读取，如果没有便阻塞等待其他 goroutine 写入数据。当 goroutine 进行数据写入时，如果缓冲队列没有满，则直接写入数据后离开。如果缓冲队列已满，则需要等待其他 goroutine 来消费缓冲队列，才能继续写入，在此之前只能一直阻塞。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;channel-数据结构&#34;&gt;Channel 数据结构&lt;/h2&gt;

&lt;p&gt;首先，我们看一下 Go 语言中 Channel 的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;# go1.13:src/runtime/chan.go:32 
type hchan struct {
	qcount   uint           // 当前channel中元素的个数
	dataqsiz uint           // 循环队列的长度
	buf      unsafe.Pointer // 指针, 指向一个长度为dataqsize的数组, 即缓冲队列
	elemsize uint16 // channel可以接收的元素大小(单个)
	closed   uint32	// channel的关闭状态
	elemtype *_type // channel可以接收的元素类型
	sendx    uint   // 标示当前可发送元素的位置(数组下标)
	recvx    uint   // 标示当前可接收元素的位置(数组下标)
	recvq    waitq  // 阻塞的接收 goroutine 队列
	sendq    waitq  // 阻塞的发送 goroutine 队列

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G&#39;s status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex	// 原子锁🔒
}

# go1.13.7:src/runtime/chan.go:53
type waitq struct {
	first *sudog	//指向队列头部的 goroutine 指针
	last  *sudog	//指向队列尾部的 goroutine 指针
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channel 在 Go 语言中是以  &lt;code&gt;hchan&lt;/code&gt; 结构体存在的，结构体中的字段如注释所示。其中  &lt;code&gt;sudog&lt;/code&gt; 可以认为是 goroutine 的额外封装。&lt;/p&gt;

&lt;h2 id=&#34;channel-创建&#34;&gt;Channel 创建&lt;/h2&gt;

&lt;p&gt;channel 的创建最终都会调用  &lt;code&gt;makechan()&lt;/code&gt; 接口，话不多说先上源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;# go1.13:src/runtime/chan.go:71
func makechan(t *chantype, size int) *hchan {
	elem := t.elem

	// compiler checks this but be safe.
	if elem.size &amp;gt;= 1&amp;lt;&amp;lt;16 {	// channel元素大小校验, 不能超过64KB
		throw(&amp;quot;makechan: invalid channel element type&amp;quot;)
	}
	if hchanSize%maxAlign != 0 || elem.align &amp;gt; maxAlign { // 内存对齐限制检查
		throw(&amp;quot;makechan: bad alignment&amp;quot;)
	}

	mem, overflow := math.MulUintptr(elem.size, uintptr(size)) //申请内存的预检查
	if overflow || mem &amp;gt; maxAlloc-hchanSize || size &amp;lt; 0 {
		panic(plainError(&amp;quot;makechan: size out of range&amp;quot;))
	}

	// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
	// buf points into the same allocation, elemtype is persistent.
	// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
	// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
	var c *hchan
	switch {
	case mem == 0:
		// Queue or element size is zero.
		c = (*hchan)(mallocgc(hchanSize, nil, true))
		// Race detector uses this location for synchronization.
		c.buf = c.raceaddr()
	case elem.ptrdata == 0:
		// Elements do not contain pointers.
		// Allocate hchan and buf in one call.
		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
		c.buf = add(unsafe.Pointer(c), hchanSize)
	default:
		// Elements contain pointers.
		c = new(hchan)
		c.buf = mallocgc(mem, elem, true)
	}

	c.elemsize = uint16(elem.size)
	c.elemtype = elem
	c.dataqsiz = uint(size)

	if debugChan {
		print(&amp;quot;makechan: chan=&amp;quot;, c, &amp;quot;; elemsize=&amp;quot;, elem.size, &amp;quot;; elemalg=&amp;quot;, elem.alg, &amp;quot;; dataqsiz=&amp;quot;, size, &amp;quot;\n&amp;quot;)
	}
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是一系列的安全检查：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查 channel 元素类型的大小，不能超过64KB。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查 chennel 元素结构体是否已经对齐，以及 channel 中的元素内存对齐值不得超过  maxAlign （在当前版本中 maxAlign 的值为8）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查缓冲队列的内存申请是否超过限制，主要有三个判断：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;申请的内存是否溢出&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;是否超过允许创建的最大内存限制。这里需要减去 channel 结构本身的内存占用 hchanSize，这个内存占用大小的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))&amp;amp;(maxAlign-1))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当然，申请的内存大小不能为负数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过安全检查之后，会声明 &lt;code&gt;hchan&lt;/code&gt; 指针 c，根据3种不同的情况对 c 进行初始化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建的是无缓冲 channel ：即申请缓冲队列的大小为0，这个时候会为 c 申请 hchanSize 大小的内存。同时调用 raceaddr() 对缓冲队列指针地址进行读写操作，主要作用是为了防止在调用 len() 或 cap() 函数时读取内存地址和其他操作产生资源竞争。&lt;/li&gt;
&lt;li&gt;创建的是有缓冲 channel 且缓冲队列元素不包含指针：会为 c 申请一段 hchanSize + mem 大小的内存，并将缓冲队列指针指向内存地址后段，即加上 hchanSize 的偏移量后指向一段长度为 mem 的内存地址。&lt;/li&gt;
&lt;li&gt;创建的是有缓冲 channel 且缓冲队列元素包含指针：分别为 c 和缓冲队列 c.buf 分配对应大小的内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;剩下的操作便是一些上文提到的变量初始化和 Debug 日志输出了。&lt;/p&gt;

&lt;h2 id=&#34;channel-发送&#34;&gt;Channel 发送&lt;/h2&gt;

&lt;p&gt;channel 的发送逻辑实现主要是在 &lt;code&gt;src/runtime/chan.go&lt;/code&gt; 中的  &lt;code&gt;chansend()&lt;/code&gt; 和 &lt;code&gt;send()&lt;/code&gt;，由于实现逻辑比较冗长，情况也比较多，这里就不直接代码骑脸，我们根据不同的情况具体分析：&lt;/p&gt;

&lt;h3 id=&#34;无缓冲-channel-发送&#34;&gt;无缓冲 channel 发送&lt;/h3&gt;

&lt;h4 id=&#34;直接发送&#34;&gt;直接发送&lt;/h4&gt;

&lt;p&gt;前文说过无缓冲 channel 在发送时，如果没有对应接收的 goroutine，就会将当前的发送 goroutine 放入 sendq 队列，所以发送时，第一步会先检查 recvq 队列是否有接收 goroutine 在等待接收， 如果已经有等待接收的 goroutine，便直接调用 &lt;code&gt;send()&lt;/code&gt; 进行数据发送：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:190
if sg := c.recvq.dequeue(); sg != nil {
	// Found a waiting receiver. We pass the value we want to send
	// directly to the receiver, bypassing the channel buffer (if any).
	send(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3)
	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;发送阻塞&#34;&gt;发送阻塞&lt;/h4&gt;

&lt;p&gt;当接收队列为空的时候，程序会检查当前 channel 的缓冲队列是否可用（当然在无缓冲 channel 中答案时肯定不行的），于是会获取当前发送的 goroutine，根据这个 goroutine 封装一个上文提到的 &lt;code&gt;sudog&lt;/code&gt; 结构并放入 sendq 队列中并将当前的 goroutine 设置为休眠状态（通过调用 &lt;code&gt;goparkunlock()&lt;/code&gt;）。同时也会调用 &lt;code&gt;KeepAlive()&lt;/code&gt; 将当前发送的数据（实际上是一个指向当前数据的指针）标记为 reachable 以防止数据在发送前被释放或修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:219
// Block on the channel. Some receiver will complete our operation for us.
gp := getg()
mysg := acquireSudog()
mysg.releasetime = 0
if t0 != 0 {
	mysg.releasetime = -1
}
// No stack splits between assigning elem and enqueuing mysg
// on gp.waiting where copystack can find it.
mysg.elem = ep
mysg.waitlink = nil
mysg.g = gp
mysg.isSelect = false
mysg.c = c
gp.waiting = mysg
gp.param = nil
c.sendq.enqueue(mysg)
goparkunlock(&amp;amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)
// Ensure the value being sent is kept alive until the
// receiver copies it out. The sudog has a pointer to the
// stack object, but sudogs aren&#39;t considered as roots of the
// stack tracer.
KeepAlive(ep)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有缓冲-channel-发送&#34;&gt;有缓冲 channel 发送&lt;/h3&gt;

&lt;h4 id=&#34;直接发送-1&#34;&gt;直接发送&lt;/h4&gt;

&lt;p&gt;同无缓冲 channel 一样，发送的第一件事是对接收队列 recvq 进行检查（因为此时如果 recvq 队列有正在等待接收的 goroutine，那么缓冲区的数据一定已经被读取完了），如果有正在等待接收的 goroutine，那么跟上文的无缓冲 channel 是一样的处理。不同的地方在于，如果 recvq 队列为空，程序会继续检查当前缓冲区是否还有空间，如果还有空间，便将发送的数据写入缓冲区，而当前的 goroutine 就可以继续往下执行了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:197
if c.qcount &amp;lt; c.dataqsiz {
	// Space is available in the channel buffer. Enqueue the element to send.
	qp := chanbuf(c, c.sendx) //获取队列下一个位置发送数据的存储位置
	if raceenabled {	//竞争检测，在当前版本中 raceenabled 默认为 false，只有在运行时加上 -race 才会成为 true
		raceacquire(qp)
		racerelease(qp)
	}
	typedmemmove(c.elemtype, qp, ep)	//将发送的数据复制到缓冲区
	c.sendx++	//缓冲区的发送指针位置调整
	if c.sendx == c.dataqsiz { //循环队列常规操作
		c.sendx = 0
	}
	c.qcount++
	unlock(&amp;amp;c.lock)
	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;发送阻塞-1&#34;&gt;发送阻塞&lt;/h4&gt;

&lt;p&gt;如果缓冲队列容量已满，那么即使是有缓冲的 channel，也会将当前发送数据的 goroutine 挂起，具体操作和无缓冲 channel 是一致的，这里就不做赘述了，可以自行查看&lt;a href=&#34;#发送阻塞&#34;&gt;无缓冲 channel 发送数据阻塞过程&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;唤醒&#34;&gt;唤醒&lt;/h3&gt;

&lt;p&gt;在阻塞状态进行了漫长的等待之后，有一天，一个从远方而来进行接收数据的 goroutine 终于出现，这个时候休眠状态的发送 goroutine 被唤醒，进行数据的收尾及释放：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:243
// someone woke us up.
if mysg != gp.waiting {
	throw(&amp;quot;G waiting list is corrupted&amp;quot;)
}
gp.waiting = nil
if gp.param == nil {
	if c.closed == 0 {
		throw(&amp;quot;chansend: spurious wakeup&amp;quot;)
	}
	panic(plainError(&amp;quot;send on closed channel&amp;quot;))
}
gp.param = nil
if mysg.releasetime &amp;gt; 0 {
	blockevent(mysg.releasetime-t0, 2)
}
mysg.c = nil
releaseSudog(mysg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要的检查有两点，一个是当前 goroutine 的锁定是否被篡改：gp.waiting 指向当前 goroutine 被占用等待的  &lt;code&gt;sudog&lt;/code&gt; 结构体。另一个检查是当前 channel 的关闭状态，倘若当前 channel 已经关闭，则会导致程序Panic，因为从一个已经关闭的 channel 中写数据是不被允许的。&lt;/p&gt;

&lt;p&gt;检查完毕之后便是对资源的回收。至此一个完整的 channel 发送流程便走完了。&lt;/p&gt;

&lt;h3 id=&#34;how-to-send&#34;&gt;How to send ？&lt;/h3&gt;

&lt;p&gt;上文提到如果是两个 gouroutine 直接进行数据交流（不经过缓冲队列），程序会调用 &lt;code&gt;send()&lt;/code&gt; 进行数据发送，那么它是如何发送数据呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:269
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
	if raceenabled {	// 正常运行状态下，raceenabled 为 false， 所以这里我们无视吧🤫
		if c.dataqsiz == 0 {
			racesync(c, sg)
		} else {
			// Pretend we go through the buffer, even though
			// we copy directly. Note that we need to increment
			// the head/tail locations only when raceenabled.
			qp := chanbuf(c, c.recvx)
			raceacquire(qp)
			racerelease(qp)
			raceacquireg(sg.g, qp)
			racereleaseg(sg.g, qp)
			c.recvx++
			if c.recvx == c.dataqsiz {
				c.recvx = 0
			}
			c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
		}
	}
	if sg.elem != nil {
		sendDirect(c.elemtype, sg, ep) // 直接将数据 ep 拷贝到接收的 goroutine 中
		sg.elem = nil
	}
	gp := sg.g
	unlockf()
	gp.param = unsafe.Pointer(sg)	//将当前的 sudog 设置为接收方 goroutine 唤醒后的参数
	if sg.releasetime != 0 {
		sg.releasetime = cputicks()
	}
	goready(gp, skip+1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;raceenabled 竞争检测相关这里我们就略过不展开讲了（其实是不会）。有兴趣的同学可以自行查阅，不要忘了学成归来评论分享。&lt;/p&gt;

&lt;p&gt;在分析发送逻辑之前我们要明确两件事：一个是在 &lt;code&gt;send()&lt;/code&gt; 中传入的 sg 已经不是发送方的  &lt;code&gt;sudog&lt;/code&gt; 结构体而是数据接收队列中的接收方。还有一点是此时数据接收方的 goroutine 必然是休眠状态的。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;send()&lt;/code&gt; 中程序调用 &lt;code&gt;sendDirect()&lt;/code&gt; 将数据 ep 的内容&lt;font color=red&gt;&lt;strong&gt;直接拷贝&lt;/strong&gt;&lt;/font&gt;到接收 goroutine 的内存空间中，然后回收指向该内存的指针，同时也会将当前的 &lt;code&gt;sudog&lt;/code&gt; 设置为接收方 goroutine 唤醒后的参数。最后通过调用 &lt;code&gt;goready()&lt;/code&gt; 唤醒休眠的接收 goroutine 来完成数据传输的过程。&lt;/p&gt;

&lt;h2 id=&#34;channel-接收&#34;&gt;Channel 接收&lt;/h2&gt;

&lt;p&gt;channel 的接收逻辑同样在 &lt;code&gt;src/runtime/chan.go&lt;/code&gt; 中，主要也是 &lt;code&gt;chanrecv()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt; 两个接口。接收逻辑大体上和发送十分类似，&lt;del&gt;甚至可以理解为仅仅是数据流动的方向改变了而已。&lt;/del&gt;主要的差异体现在数据的交换逻辑。&lt;/p&gt;

&lt;h3 id=&#34;无缓冲-channel-接收&#34;&gt;无缓冲 channel 接收&lt;/h3&gt;

&lt;h4 id=&#34;直接接收&#34;&gt;直接接收&lt;/h4&gt;

&lt;p&gt;无缓冲 channel 在进行数据接收时，如果发送队列 sendq 已经有等待的发送 goroutine，那么当前 goroutine 会直接和这个发送者进行数据拷贝：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:473
if sg := c.sendq.dequeue(); sg != nil { 	//如果数据发送等待队列有正在等待的 goroutine
	// Found a waiting sender. If buffer is size 0, receive value
	// directly from sender. Otherwise, receive from head of queue
	// and add sender&#39;s value to the tail of the queue (both map to
	// the same buffer slot because the queue is full).
	recv(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3) //数据接收处理
	return true, true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;接收阻塞&#34;&gt;接收阻塞&lt;/h4&gt;

&lt;p&gt;当发送队列 sendq 上没有正在等待发送数据的 goroutine 时，由于不存在缓冲队列，当前 goroutine 需要包装成上文提到的 &lt;code&gt;sudog&lt;/code&gt; 结构体并插入到数据接收等待队列 recvq 中。之后便是调用 &lt;code&gt;goparkunlock()&lt;/code&gt; 让当前 goroutine 进入漫长的等待了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// no sender available: block on this channel.
gp := getg()
mysg := acquireSudog()
mysg.releasetime = 0
if t0 != 0 {
	mysg.releasetime = -1
}
// No stack splits between assigning elem and enqueuing mysg
// on gp.waiting where copystack can find it.
mysg.elem = ep
mysg.waitlink = nil
gp.waiting = mysg
mysg.g = gp
mysg.isSelect = false
mysg.c = c
gp.param = nil
c.recvq.enqueue(mysg)
goparkunlock(&amp;amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和发送略微不同的是，由于数据接收操作并没有数据需要保护，所以并不需要类似 &lt;code&gt;KeepAlive()&lt;/code&gt; 这样的接口来对数据进行安全锁定。&lt;/p&gt;

&lt;h3 id=&#34;有缓冲-channel-接收&#34;&gt;有缓冲 channel 接收&lt;/h3&gt;

&lt;h4 id=&#34;直接接收-1&#34;&gt;直接接收&lt;/h4&gt;

&lt;p&gt;当 goroutine 从某个有缓冲 channel 接收数据时，依然会对发送队列 sendq 进行检查，如果队列中有等待发送的对象，那么表示当前有许多数据可以接收（满容量缓冲队列+发送等待队列），接收的 goroutine 会调用 &lt;code&gt;recv()&lt;/code&gt; 接口进行数据交接。但是！请不要误会数据接收的对象是等待队列中的发送者。channel 的调度遵循 FIFO 原则，不会因为你是一个正在等待的 goroutine 而优先处理。然而具体是如何接收数据，在此先买个关子。&lt;/p&gt;

&lt;p&gt;倘若发送队列 sendq 中没有等待的发送对象，不要慌，我们还有缓冲池。当缓冲队列大小不为0时，说明仍有数据可供接收，当前的 goroutine 会调用 &lt;code&gt;typedmemmove()&lt;/code&gt; 将缓冲区的数据拷贝到自己的内存中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:482
if c.qcount &amp;gt; 0 {	//判断循环队列中的缓冲对象
	// Receive directly from queue
	qp := chanbuf(c, c.recvx)
	if raceenabled {
		raceacquire(qp)
		racerelease(qp)
	}
	if ep != nil {
		typedmemmove(c.elemtype, ep, qp)	//直接将缓冲区中的数据拷贝到当前 goroutine 中
	}
	typedmemclr(c.elemtype, qp)	//清除缓冲区中的数据
	c.recvx++
	if c.recvx == c.dataqsiz {	//循环队列常规操作
		c.recvx = 0
	}
	c.qcount--
	unlock(&amp;amp;c.lock)
	return true, true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;接收阻塞-1&#34;&gt;接收阻塞&lt;/h4&gt;

&lt;p&gt;当缓冲队列中也没有可接收数据时，即使是一个有缓冲的 channel，goroutine 也要乖乖进入阻塞状态，这里的逻辑和上文中无缓冲 channel 接收阻塞逻辑是一样的，可以自行回顾&lt;a href=&#34;#接收阻塞&#34;&gt;无缓冲 channel 接收数据阻塞过程&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;唤醒-1&#34;&gt;唤醒&lt;/h3&gt;

&lt;p&gt;阻塞状态的接收 goroutine 在漫长的等待之后被唤醒，这个时候它会发现数据已经拷贝到自己的内存中（类似于睡了一天然后醒来发现一天的工资已经发到银行卡里那种感觉），需要自己做的仅仅是数据的整理检查等收尾工作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:526
// someone woke us up
if mysg != gp.waiting {
	throw(&amp;quot;G waiting list is corrupted&amp;quot;)
}
gp.waiting = nil
if mysg.releasetime &amp;gt; 0 {
	blockevent(mysg.releasetime-t0, 2)
}
closed := gp.param == nil
gp.param = nil
mysg.c = nil
releaseSudog(mysg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的检查相较于发送的唤醒操作少了一个 channel 的关闭状态检查。因为在设计上，即使 channel 已经被关闭，只要还有数据残留，channel 依然是可读的。&lt;/p&gt;

&lt;h3 id=&#34;how-to-receive&#34;&gt;How to receive ？&lt;/h3&gt;

&lt;p&gt;到目前为止，channel 中接收和发送的逻辑还是十分相似的，真正的区别在于 &lt;code&gt;send()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt; 的实现，也就是实际的数据传输操作。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;recv()&lt;/code&gt; 函数中，程序只知道有数据需要接收，但不确定数据源是从 &lt;code&gt;sudog&lt;/code&gt; 对象中还是从缓冲队列中获取，所以在接收数据前还需要根据 channel 的状态进行判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;# go1.13:src/runtime/chan.go:554
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
	if c.dataqsiz == 0 {	//无缓冲 channel 处理入口
		if raceenabled {
			racesync(c, sg)
		}
		if ep != nil {
			// copy data from sender
			recvDirect(c.elemtype, sg, ep)	//直接从发送的 goroutine 中拷贝数据
		}
	} else {	// 看注释↓↓↓↓↓↓
		// Queue is full. Take the item at the
		// head of the queue. Make the sender enqueue
		// its item at the tail of the queue. Since the
		// queue is full, those are both the same slot.
		qp := chanbuf(c, c.recvx)
		if raceenabled {	// 不用管系列
			raceacquire(qp)
			racerelease(qp)
			raceacquireg(sg.g, qp)
			racereleaseg(sg.g, qp)
		}
		// copy data from queue to receiver
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)	//将缓冲队列队首的数据拷贝到当前接收数据的 goroutine 中
		}
		// copy data from sender to queue
		typedmemmove(c.elemtype, qp, sg.elem)	//将阻塞的发送 goroutine 中的数据拷贝到缓冲队列中
		c.recvx++
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
		c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
	}
	sg.elem = nil
	gp := sg.g
	unlockf()
	gp.param = unsafe.Pointer(sg)
	if sg.releasetime != 0 {
		sg.releasetime = cputicks()
	}
	goready(gp, skip+1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，传入的 sg 是发送数据方的一个已经进入休眠的 &lt;code&gt;sudog&lt;/code&gt; 结构体。 首先检查缓冲队列大小，如果大小为0（无缓冲 channel ），调用 &lt;code&gt;recvDirect()&lt;/code&gt; 对数据进行&lt;font color=red&gt;&lt;strong&gt;直接拷贝&lt;/strong&gt;&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;如果是有缓冲队列的 channel，那么表示缓冲队列已经满员（因为发送队列已经有 goroutine 阻塞），接下来需要完成两件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将缓冲队列队首的数据拷贝到当前接收数据的 goroutine 中。&lt;/li&gt;
&lt;li&gt;将阻塞的发送 goroutine 中的数据拷贝到缓冲队列队尾中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完成了数据交接后，调用 &lt;code&gt;goready()&lt;/code&gt; 轻轻唤醒阻塞的数据发送 goroutine，深藏功与名。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;许多文章将 channel 类比为“管道”之类的工具，但在了解 channel 的完整调度逻辑后，我更希望将其比作一个高速公路中的货物中转站。来来往往的货车司机（goroutine）在此装货卸货，有无仓库（缓冲）决定了货车司机需不需要在中转站逗留等待，迟到的货车司机负责货物的装载或拆卸（数据传输）并通知对应的司机完成货物交接。&lt;/li&gt;
&lt;li&gt;Go 基于 CSP 模型中的 process 和 channel 的概念设计了基于 channel 的并发模型并提倡“通过通信共享内存，而不是通过共享内存来通信”。然而这更多是一种行为上的概念，实际实现中还是无法避免地共享了 hchan 甚至缓冲 buf 等数据结构。唯一不同的是当两个 goroutine 直接交换数据时，他们是可以直接操作对方的内存空间（通过 &lt;code&gt;sendDirect()&lt;/code&gt; 和 &lt;code&gt;recvDirect()&lt;/code&gt; 两个方法），避免了数据的多次拷贝和额外的锁操作。&lt;/li&gt;
&lt;li&gt;为了遵循 FIFO 原则，Go 语言用两个指针加数组实现了循环队列，实际上这大概也是队列的最佳实现方式了 &amp;hellip; &amp;hellip; 吧？&lt;/li&gt;
&lt;li&gt;channel 使用 mutex 来保障它是 goroutine 安全的，但是作为一个对性能要求极高的数据结构，我们可以发现解锁操作并不一定是在当前加锁的处理函数中。它通过传递解锁接口 &lt;code&gt;unlockf()&lt;/code&gt; 来确保对数据修改结束后第一时间进行锁的释放，从而实现锁的覆盖时间是最短的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/kavya719/understanding-channels&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;diving-deep-into-the-golang-channels&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MySQL 多版本并发控制</title>
      <link>https://aka-bingo.github.io/2019/05/mysql-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 25 May 2019 15:47:10 +0800</pubDate>
      
      <guid>https://aka-bingo.github.io/2019/05/mysql-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>

&lt;h2 id=&#34;什么是多版本并发控制-mvcc&#34;&gt;什么是多版本并发控制（ MVCC ）&lt;/h2&gt;

&lt;p&gt;MySQL 的大多数事务型存储引擎基于提升并发性能的考虑，一般都实现了多版本并发控制（ MVCC ）。MVCC 是行级锁的一个变种，但实际上实现机制有所不同，避免了加锁的操作，因此有了更低的开销和更高的性能。&lt;/p&gt;

&lt;p&gt;MVCC 的实现，是通过保持数据在某个时间点的快照来实现的，不管事务的执行时间有多久，MVCC 保障了每一个事务内看到的数据是一致的，而根据事务开始时间，不同事务看到同一张表，同一份数据可能是不同的。&lt;/p&gt;

&lt;p&gt;不同存储引擎对 MVCC 的实现机制不尽相同，因为 MVCC 并没有一个统一的标准，下面以 InnoDB 为例，简要介绍 MVCC 的实现原理。&lt;/p&gt;

&lt;h2 id=&#34;innodb-中的-mvcc&#34;&gt;InnoDB 中的 MVCC&lt;/h2&gt;

&lt;p&gt;InnoDB 中的 MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个特殊的列一个保存了行的创建时间，一个保存了行的删除时间。当然这里存储的并不是真实的时间，实际上存储的是&lt;strong&gt;版本号&lt;/strong&gt;（ system version number ）。每次开启一个新的事务，系统版本号会开始递增并分配给当前的事务，用于与数据的版本号进行比较。简要介绍下 InnoDB 是如何操作的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SELECT：在 InnoDB 中，SELECT 操作有两个额外的条件：

&lt;ol&gt;
&lt;li&gt;只查找行的创建版本号小于或等于当前事务版本号的数据。这样可以保证事务读取的数据要么是在事务开始之前就已经存在，要么是事务本身插入或者修改过的。&lt;/li&gt;
&lt;li&gt;行的删除版本号要么未定义，要么大于当前事务的版本号。这样是为了确保事务读取的数据在事务开始之前未被删除。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;INSERT：InnoDB 为每行新增数据设置了当前事务的版本号作为创建版本号，删除版本号留空。&lt;/li&gt;
&lt;li&gt;DELETE：InnoDB 为每行删除的数据设置了当前事务的版本号作为删除版本号。&lt;/li&gt;
&lt;li&gt;UPDATE：InnoDB 额外插入一条新的记录，将当前事务版本号作为新记录的创建版本号，同时保存当前事务版本号到原来的数据中的删除版本号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 InnoDB 中，MVCC 只在 READ COMMITTED 和 REPEATABLE READ 这两个隔离级别下工作。其他的隔离级别和 MVCC 并不兼容，READ UNCOMMITTED 总是读取最新的数据，而 SERIALIZABLE 则会对所有读取的行都进行加锁操作。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;MVCC 解决了多个事务并发过程中产生的幻读问题。通过保存额外的两个系统版本号字段，使得大部分读操作可以不用加锁，提高了读取性能的同时也保障了读取范围的可靠性。唯一的不足是每行数据都需要额外的存储空间，以及需要更多的行检查和维护工作，但是在数据读取保障和性能方面的巨大提升前提下，这些不足便显得十分容易接受了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库事务隔离级别</title>
      <link>https://aka-bingo.github.io/2019/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Wed, 22 May 2019 21:48:03 +0800</pubDate>
      
      <guid>https://aka-bingo.github.io/2019/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;脏读（ Dirty Read ）：当事务 A 对数据进行修改后，事务 B 读取了被改动后的数据，此时事务 A 进行了异常回滚，事务B读取到的是未经提交的数据，称之为脏读。&lt;/li&gt;
&lt;li&gt;不可重复读（ NonRepeatable Read ）：事务 A 中读取了数据后，事务 B 对数据进行了修改并提交，事务 A 再次对数据进行读取发现前后不一致，称之为不可重复读。&lt;/li&gt;
&lt;li&gt;幻读（ Phantom Read ）：事务 A 在读取某个范围内的记录时，事务 B 在该范围内插入了新的记录，事务 A 再次进行数据统计后得到不同的结果，称之为幻读。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS：不可重复读和幻读从结果上看十分相似，都是数据在两次读取间隔间进行修改导致两次读取的结果不一致，他们的区别在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不可重复读指的是一个事务内对同一数据的多次读取的情况。&lt;/li&gt;
&lt;li&gt;幻读指的是事务的读取范围被其他事务改变的情况。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h2&gt;

&lt;p&gt;在 SQL 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见或不可见的。较低级的隔离级别一般系统的开销也更低，可以支撑更高的并发，但是对上层应用的数据读取可能会造成影响。&lt;/p&gt;

&lt;h3 id=&#34;read-uncommitted-未提交读&#34;&gt;READ UNCOMMITTED 未提交读&lt;/h3&gt;

&lt;p&gt;在 READ UNCOMMITTED 隔离级别下，事务可以对其他事务中尚未提交的数据修改进行读取。这个级别会导致很多问题，比如脏读，在实际应用中一般很少使用。&lt;/p&gt;

&lt;h3 id=&#34;read-committed-提交读&#34;&gt;READ COMMITTED 提交读&lt;/h3&gt;

&lt;p&gt;在 READ COMMITTED 隔离级别下，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。该隔离级别避免了脏读的发生，但是一个事务内的查询，依然有可能获得不同的结果（数据被其他事务修改），导致产生不可重复读。&lt;/p&gt;

&lt;h3 id=&#34;repeatable-read-可重复读&#34;&gt;REPEATABLE READ 可重复读&lt;/h3&gt;

&lt;p&gt;REPEATABLE READ 解决了脏读&amp;amp;幻读的问题，该隔离级别保证了在同一个事务中多次读取同样的记录结果是一致的。但是该隔离级别依然会导致幻读的问题。&lt;/p&gt;

&lt;p&gt;PS：在 SQL 标准中，REPEATABLE READ 无法解决幻读的问题，但是 MySQL 中 InnoDB 和 XtraDB 存储引擎通过&lt;a href=&#34;../mysql 多版本并发控制/&#34;&gt;多版本并发控制（ MVCC，MultiVersion Concurrency Control ）&lt;/a&gt;解决了幻读的问题。&lt;/p&gt;

&lt;h3 id=&#34;serializable-可串行化&#34;&gt;SERIALIZABLE 可串行化&lt;/h3&gt;

&lt;p&gt;SERIALIZABLE 是最高的隔离级别，通过强制事务串行执行，避免了数据的读取问题。该隔离级别对读取的每一行数据都进行加锁，可能会因为大量的超时和锁调度的问题导致性能下降。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;隔离级别&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;脏读&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;不可重复读&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;幻读&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;加锁读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;READ UNCOMMITTED&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;READ COMMITTED&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;REPEATABLE READ&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SERIALIZABLE&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;READ UNCOMMITTED：从性能上来讲，未提交读不会比其他隔离级别好太多，但是带来的问题和风险远远高于其他隔离级别。除非真的有足够必要的使用理由，否则远离他。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;READ COMMITTED：大多数数据库的默认隔离级别都是提交读，如 SQL Server，Oracle。解决了脏读的问题，但是无法避免数据被其他事务修改过程前后读取不一致的情况。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;REPEATABLE READ：在 MySQL 中，可重复读是默认的事务隔离级别，保障了一个事务在多次读取数据过程中，其他数据无法操作该数据。但是依然避免不了新数据的插入，产生幻读。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SERIALIZABLE：完全串行化地执行事务，每次读都需要获得表级共享锁，最安全，也是性能最差的隔离级别。只有在非常x3需要确保数据一致性而且可以接受无法并发的情况，才能考虑使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://aka-bingo.github.io/about/</link>
      <pubDate>Sun, 24 Feb 2019 22:54:39 +0800</pubDate>
      
      <guid>https://aka-bingo.github.io/about/</guid>
      <description>

&lt;h3 id=&#34;gopher-phper-拖延症晚期患者&#34;&gt;Gopher, PHPer，拖延症晚期患者&lt;/h3&gt;

&lt;h3 id=&#34;study-in-深圳大学&#34;&gt;Study in 深圳大学&lt;/h3&gt;

&lt;h3 id=&#34;work-in-kingdee-企业云盘&#34;&gt;Work in Kingdee-企业云盘&lt;/h3&gt;

&lt;h3 id=&#34;我会这里记录-日常见闻-所学所想-立各种各样的flag&#34;&gt;我会这里记录 日常见闻 &amp;amp; 所学所想 &amp;amp; 立各种各样的Flag&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>你好呀，2018</title>
      <link>https://aka-bingo.github.io/2018/02/%E4%BD%A0%E5%A5%BD%E5%91%802018/</link>
      <pubDate>Thu, 22 Feb 2018 22:34:47 +0800</pubDate>
      
      <guid>https://aka-bingo.github.io/2018/02/%E4%BD%A0%E5%A5%BD%E5%91%802018/</guid>
      <description>&lt;p&gt;过去一年基本都懒得没怎么更新，新的一年要做出改变了，一些比较好的事情需要养成习惯，比如跑步、看书，记录生活的点滴吧。&lt;/p&gt;

&lt;p&gt;说起跑步主要是因为去年长时间对着电脑工作，周末又懒，体型隐隐有发福的迹象，&lt;del&gt;其实已经在发福了&lt;/del&gt;。新的一年和同事约好每周都去跑步，希望能坚持下来养成一个好习惯吧。毕竟对身体也是有好处的。&lt;/p&gt;

&lt;p&gt;另一件事是看书。去年买了一些杂书，当然也有专业的书啦，不过基本没怎么看，目前看完的只有《宇宙简史》。新的一年每天都要抽个至少半个小时来看书吧。周末可以多点时间。平时很多时间浪费在漫无目的地上网逛视频，确实有点浪费了😭&lt;/p&gt;

&lt;p&gt;过去一年进步其实不大，没有系统的学习曲线和目标，自制力也不足。新的一年主要深入研究一下 Golang 以及主流框架吧，后期尽量能够用 Go 做出一些东西，外包也好自己的脑洞也罢。另外需要把学到的写下来巩固记忆，不要等用到的时候又忘记了。尽量深入地了解各种事物而不是浮于表面，不然记忆下来的东西也是十分有限。&lt;/p&gt;

&lt;p&gt;如果还有多余的时间的话，希望能当个天文学小迷弟哈哈哈哈哈。&lt;/p&gt;

&lt;p&gt;这一次过年过得是真的很纠结，差点做了一些影响自己一生的决定。不知道是一个好的开始还是坏的，但是希望以后做的决定都能够充足地思考以及让自己不后悔吧。来到深圳第五年了，隐隐有了逃离的念头，现在也要开始对以后的走向认认真真地规划而不是空想了。&lt;/p&gt;

&lt;p&gt;以上是2018年的 Flag，虽然全都是希望，2019年来验证一下是否变成现实吧！&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这篇文章是无意中在以前的博客（ Git Page ）看到的。回头看看其实很多事道理都懂但是意志力不够坚强没法贯彻，迁移到目前的 Blog 中半讽刺半鞭策一下自己吧。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>