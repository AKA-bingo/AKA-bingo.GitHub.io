<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on BinGo&#39;s Blog</title>
    <link>https://aka-bingo.github.io/tags/mysql/</link>
    <description>Recent content in MySQL on BinGo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 25 May 2019 15:47:10 +0800</lastBuildDate>
    
	<atom:link href="https://aka-bingo.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL 多版本并发控制</title>
      <link>https://aka-bingo.github.io/2019/05/mysql-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 25 May 2019 15:47:10 +0800</pubDate>
      
      <guid>https://aka-bingo.github.io/2019/05/mysql-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>什么是多版本并发控制（ MVCC ） MySQL 的大多数事务型存储引擎基于提升并发性能的考虑，一般都实现了多版本并发控制（ MVCC ）。MVCC 是行级锁的一个变种，但实际上实现机制有所不同，避免了加锁的操作，因此有了更低的开销和更高的性能。
MVCC 的实现，是通过保持数据在某个时间点的快照来实现的，不管事务的执行时间有多久，MVCC 保障了每一个事务内看到的数据是一致的，而根据事务开始时间，不同事务看到同一张表，同一份数据可能是不同的。
不同存储引擎对 MVCC 的实现机制不尽相同，因为 MVCC 并没有一个统一的标准，下面以 InnoDB 为例，简要介绍 MVCC 的实现原理。
InnoDB 中的 MVCC InnoDB 中的 MVCC，是通过在每行记录后保存两个隐藏的列来实现的。这两个特殊的列一个保存了行的创建时间，一个保存了行的删除时间。当然这里存储的并不是真实的时间，实际上存储的是版本号（ system version number ）。每次开启一个新的事务，系统版本号会开始递增并分配给当前的事务，用于与数据的版本号进行比较。简要介绍下 InnoDB 是如何操作的：
 SELECT：在 InnoDB 中，SELECT 操作有两个额外的条件：  只查找行的创建版本号小于或等于当前事务版本号的数据。这样可以保证事务读取的数据要么是在事务开始之前就已经存在，要么是事务本身插入或者修改过的。 行的删除版本号要么未定义，要么大于当前事务的版本号。这样是为了确保事务读取的数据在事务开始之前未被删除。  INSERT：InnoDB 为每行新增数据设置了当前事务的版本号作为创建版本号，删除版本号留空。 DELETE：InnoDB 为每行删除的数据设置了当前事务的版本号作为删除版本号。 UPDATE：InnoDB 额外插入一条新的记录，将当前事务版本号作为新记录的创建版本号，同时保存当前事务版本号到原来的数据中的删除版本号。  在 InnoDB 中，MVCC 只在 READ COMMITTED 和 REPEATABLE READ 这两个隔离级别下工作。其他的隔离级别和 MVCC 并不兼容，READ UNCOMMITTED 总是读取最新的数据，而 SERIALIZABLE 则会对所有读取的行都进行加锁操作。
总结 MVCC 解决了多个事务并发过程中产生的幻读问题。通过保存额外的两个系统版本号字段，使得大部分读操作可以不用加锁，提高了读取性能的同时也保障了读取范围的可靠性。唯一的不足是每行数据都需要额外的存储空间，以及需要更多的行检查和维护工作，但是在数据读取保障和性能方面的巨大提升前提下，这些不足便显得十分容易接受了。</description>
    </item>
    
  </channel>
</rss>