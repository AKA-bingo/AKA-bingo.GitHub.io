<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>隔离级别 on BinGo&#39;s Blog</title>
    <link>https://www.hybingo.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
    <description>Recent content in 隔离级别 on BinGo&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 May 2019 21:48:03 +0800</lastBuildDate>
    
	<atom:link href="https://www.hybingo.com/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据库事务隔离级别</title>
      <link>https://www.hybingo.com/2019/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Wed, 22 May 2019 21:48:03 +0800</pubDate>
      
      <guid>https://www.hybingo.com/2019/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>定义  脏读（ Dirty Read ）：当事务 A 对数据进行修改后，事务 B 读取了被改动后的数据，此时事务 A 进行了异常回滚，事务B读取到的是未经提交的数据，称之为脏读。 不可重复读（ NonRepeatable Read ）：事务 A 中读取了数据后，事务 B 对数据进行了修改并提交，事务 A 再次对数据进行读取发现前后不一致，称之为不可重复读。 幻读（ Phantom Read ）：事务 A 在读取某个范围内的记录时，事务 B 在该范围内插入了新的记录，事务 A 再次进行数据统计后得到不同的结果，称之为幻读。  PS：不可重复读和幻读从结果上看十分相似，都是数据在两次读取间隔间进行修改导致两次读取的结果不一致，他们的区别在于：
 不可重复读指的是一个事务内对同一数据的多次读取的情况。 幻读指的是事务的读取范围被其他事务改变的情况。  隔离级别 在 SQL 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见或不可见的。较低级的隔离级别一般系统的开销也更低，可以支撑更高的并发，但是对上层应用的数据读取可能会造成影响。
READ UNCOMMITTED 未提交读 在 READ UNCOMMITTED 隔离级别下，事务可以对其他事务中尚未提交的数据修改进行读取。这个级别会导致很多问题，比如脏读，在实际应用中一般很少使用。
READ COMMITTED 提交读 在 READ COMMITTED 隔离级别下，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。该隔离级别避免了脏读的发生，但是一个事务内的查询，依然有可能获得不同的结果（数据被其他事务修改），导致产生不可重复读。
REPEATABLE READ 可重复读 REPEATABLE READ 解决了脏读&amp;amp;幻读的问题，该隔离级别保证了在同一个事务中多次读取同样的记录结果是一致的。但是该隔离级别依然会导致幻读的问题。
PS：在 SQL 标准中，REPEATABLE READ 无法解决幻读的问题，但是 MySQL 中 InnoDB 和 XtraDB 存储引擎通过多版本并发控制（ MVCC，MultiVersion Concurrency Control ）解决了幻读的问题。</description>
    </item>
    
  </channel>
</rss>